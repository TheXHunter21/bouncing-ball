<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Battle Balls â€” morph amarillo + ajustes</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 0; font-family: system-ui, Segoe UI, Roboto, sans-serif; display: grid; place-items: center; min-height: 100dvh; gap: 12px; }
  .wrap { display: grid; gap: 10px; width: min(900px, 96vw); }
  .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  input[type="number"], input[type="range"] { padding: 6px 8px; border-radius: 10px; border: 1px solid #8884; }
  input[type="range"] { width: 180px; }
  button { padding: 8px 14px; border: 0; border-radius: 12px; cursor: pointer; box-shadow: 0 2px 10px #0002; }
  button:disabled { opacity: 0.6; cursor: not-allowed; }
  .hud { font-weight: 600; display:flex; gap:12px; flex-wrap: wrap; align-items:center;}
  .scoreboard { display:flex; gap:10px; flex-wrap: wrap; }
  .badge { padding: 2px 8px; border-radius: 999px; font-weight: 700; box-shadow: 0 1px 4px #0002; background: transparent; }
  canvas { width: 100%; aspect-ratio: 1 / 1; background: conic-gradient(from 180deg at 50% 50%, #fff0, #fff0); border-radius: 16px; box-shadow: inset 0 0 0 1px #0002; }

  .log-toggle { margin-left: auto; }
  .log-overlay {
    position: fixed; inset: 16px 16px auto auto;
    width: min(420px, 95vw); height: 60vh;
    background: rgba(20,20,20,.85); color: #fafafa;
    border: 1px solid #ffffff20; border-radius: 12px;
    box-shadow: 0 10px 30px #0008; z-index: 9999; display: none;
    backdrop-filter: blur(6px);
  }
  .log-overlay header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 10px; border-bottom: 1px solid #ffffff22; font-weight: 700;
  }
  .log-overlay header .btns { display: flex; gap: 8px; }
  .log-overlay button {
    background: #ffffff14; color: #fff; border-radius: 10px;
    padding: 6px 10px; box-shadow: none; border: 1px solid #ffffff18;
  }
  .log-overlay main {
    padding: 8px 10px; height: calc(60vh - 48px - 12px);
    overflow: auto; font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: 12px; line-height: 1.35;
  }
  .log-line { opacity: .92; }
  .log-time { color: #9ad0ff; }
  .log-info { color: #d6f5d6; }
  .log-warn { color: #ffe59a; }
  .log-err  { color: #ffb3b3; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="controls">
      <label>Pelotitas:
        <input id="ballCount" type="number" value="3" min="1" max="50" step="1" />
      </label>

      <label>PÃ­ldoras mÃ¡x.:
        <input id="maxPills" type="number" value="20" min="0" step="1" />
      </label>

      <label>Frecuencia spawn:
        <input id="spawnRate" type="range" min="25" max="300" value="250" step="5" />
        <span id="spawnRateVal">250%</span>
      </label>

      <button id="toggleEdgeGrow">Rebote crece: OFF</button>

      <button id="start">INICIAR</button>
      <button id="pause" disabled>Pausar</button>
      <button id="reset">Reiniciar</button>
      <button id="toggleLog" class="log-toggle">Logs</button>
    </div>

    <div class="hud">
      Tiempo: <span id="time">0.00</span>s
      <div id="scoreboard" class="scoreboard"></div>
    </div>

    <canvas id="game"></canvas>
  </div>

  <div id="logOverlay" class="log-overlay" aria-hidden="true">
    <header>
      <span>Eventos</span>
      <div class="btns">
        <button id="clearLog">Limpiar</button>
        <button id="closeLog" title="Cerrar">âœ•</button>
      </div>
    </header>
    <main id="logBody" aria-live="polite"></main>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // UI
  const ballCountInput = document.getElementById('ballCount');
  const maxPillsInput   = document.getElementById('maxPills');
  const spawnRateInput  = document.getElementById('spawnRate');
  const spawnRateVal    = document.getElementById('spawnRateVal');

  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const resetBtn = document.getElementById('reset');
  const toggleEdgeGrowBtn = document.getElementById('toggleEdgeGrow');

  const timeEl = document.getElementById('time');
  const scoreboardEl = document.getElementById('scoreboard');

  const logOverlay = document.getElementById('logOverlay');
  const logBody = document.getElementById('logBody');
  const toggleLogBtn = document.getElementById('toggleLog');
  const closeLogBtn = document.getElementById('closeLog');
  const clearLogBtn = document.getElementById('clearLog');

  // Estado global
  let state = 'idle'; // 'idle' | 'running' | 'ended'
  let paused = false, pauseStartMs = 0, pauseAccumMs = 0;

  // Mundo & fÃ­sicas
  let R, baseSpeed, defaultSpeed; // defaultSpeed = baseSpeed * 2.25 (antes 1.5)
  let startTime = 0, elapsed = 0, rafId = null;

  // PÃ­ldoras
  const pills = [];
  const PILL_RADIUS = 16; // rombos: radio de colisiÃ³n
  let nextSpawnAt = null;
  let maxPills = 20;
  let spawnRatePct = 250;

  // Pelotas
  const balls = [];
  const LEVEL_START = 5;
  let ballCount = 3;
  const SPAWN_IMMUNITY_MS = 700;
  let edgeGrowEnabled = false; // ahora arranca OFF

  // Morph global (pÃ­ldora amarilla)
  let morphType = null;            // 'blue' | 'red' | 'greenFast' | 'greenSlow' | 'cyanShield'
  let morphUntil = 0;
  const MORPH_DURATION_MS = 8000;  // 8 segundos

  // Logs
  const logs = [];
  const LOG_MAX = 700;
  function fmtTime(sec) { return sec.toFixed(2).padStart(5, '0'); }
  function addLog(msg, level = 'info') {
    const t = state === 'idle' ? 0 : Math.max(0, (performance.now() - startTime - pauseAccumMs) / 1000);
    const line = { t, msg, level };
    logs.push(line);
    if (logs.length > LOG_MAX) logs.shift();
    if (logOverlay.style.display === 'block') renderLogs();
  }
  function renderLogs() {
    logBody.innerHTML = logs.map(l => {
      const cls = l.level === 'warn' ? 'log-warn' : l.level === 'err' ? 'log-err' : 'log-info';
      return `<div class="log-line"><span class="log-time">[${fmtTime(l.t)}]</span> <span class="${cls}">${l.msg}</span></div>`;
    }).join('');
    logBody.scrollTop = logBody.scrollHeight;
  }
  function toggleLogs() {
    const show = logOverlay.style.display !== 'block';
    logOverlay.style.display = show ? 'block' : 'none';
    logOverlay.setAttribute('aria-hidden', show ? 'false' : 'true');
    if (show) renderLogs();
  }

  // Utils
  function randomRange(a, b) { return a + Math.random() * (b - a); }
  function randomAngle() { return Math.random() * Math.PI * 2; }
  function scheduleNextSpawn(now = performance.now(), delayMs) {
    if (typeof delayMs === 'number') { nextSpawnAt = now + delayMs; return; }
    const factor = 100 / spawnRatePct;
    const base = randomRange(1500, 4000);
    nextSpawnAt = now + base * factor;
  }
  function randomNonBlueRedColor() {
    while (true) {
      const h = Math.floor(Math.random() * 360);
      const redZone = (h <= 15 || h >= 345);
      const blueZone = (h >= 200 && h <= 260);
      if (!redZone && !blueZone) {
        const s = 70 + Math.random() * 20;
        const l = 55 + Math.random() * 15;
        return `hsl(${h} ${s}% ${l}%)`;
      }
    }
  }

  // % de crecimiento segÃºn nivel
  function pctForLevel(level) {
    if (level <= 0) return 0;
    if (level <= 10) return 25;
    if (level <= 15) return 20;
    if (level <= 20) return 15;
    if (level <= 25) return 10;
    return 5;
  }

  // Crecer / Decrecer (con escudo)
  function applyGrowthStep(ball, source) {
    const prev = ball.level;
    ball.level++;
    const pct = pctForLevel(ball.level);
    ball.r = Math.min(R, ball.r * (1 + pct/100));
    addLog(`${ball.id} ${source}: nivel ${prev}â†’${ball.level} (+${pct}%)`);
    updateScoreboard();
  }
  function tryShrink(ball, source) {
    if (ball.shield) {
      ball.shield = false;
      addLog(`${ball.id}: ESCUDO bloqueÃ³ ${source}`, 'warn');
      updateScoreboard();
      return;
    }
    applyShrinkStep(ball, source);
  }
  function applyShrinkStep(ball, source) {
    const prev = ball.level;
    const pct = pctForLevel(ball.level);
    ball.r = Math.max(2, ball.r / (1 + pct/100));
    ball.level--;
    addLog(`${ball.id} ${source}: nivel ${prev}â†’${ball.level} (âˆ’${pct}%)`);
    updateScoreboard();
    if (ball.level <= 0) {
      ball.alive = false;
      addLog(`${ball.id} ha muerto (nivel 0).`, 'err');
    }
  }

  // Velocidad (por pelota) y efectos
  function effectiveSpeed(ball, nowMs) {
    if (ball.speedEffect !== 'none' && nowMs >= ball.speedEffectUntil) {
      const prev = ball.speedEffect;
      ball.speedEffect = 'none';
      addLog(`${ball.id}: Fin efecto de velocidad (${prev})`, 'warn');
    }
    if (ball.speedEffect === 'boost') return defaultSpeed * 2;
    if (ball.speedEffect === 'slow')  return defaultSpeed * 0.5;
    return defaultSpeed;
  }
  function setSpeedEffect(ball, type, nowMs) {
    ball.speedEffect = type; // 'boost' | 'slow'
    ball.speedEffectUntil = nowMs + 5000;
    addLog(`${ball.id}: Efecto velocidad â†’ ${type === 'boost' ? '2Ã—' : '0.5Ã—'} (5s)`, 'warn');
  }
  function applySpeedToVelocity(ball, targetSpeed) {
    const mag = Math.hypot(ball.vel.x, ball.vel.y);
    if (mag > 0) {
      const nx = ball.vel.x / mag, ny = ball.vel.y / mag;
      ball.vel.x = nx * targetSpeed;
      ball.vel.y = ny * targetSpeed;
    }
  }

  // Mundo
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssSize = Math.min(window.innerWidth * 0.96, 900);
    canvas.width = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    ctx.translate(cssSize/2, cssSize/2);
    R = (cssSize/2) - 10;
    baseSpeed = R * 0.45;
    defaultSpeed = baseSpeed * 2.25; // â† velocidad por defecto aumentada 1.5Ã—
    addLog('Canvas redimensionado', 'info');
  }

  function clampInputs() {
    let n = Number(ballCountInput.value); if (!Number.isFinite(n)) n = 1;
    ballCount = Math.max(1, Math.min(50, Math.floor(n)));
    ballCountInput.value = String(ballCount);

    let mp = Number(maxPillsInput.value); if (!Number.isFinite(mp)) mp = 20;
    maxPills = Math.max(0, Math.floor(mp));
    maxPillsInput.value = String(maxPills);

    let sr = Number(spawnRateInput.value); if (!Number.isFinite(sr)) sr = 250;
    spawnRatePct = Math.max(25, Math.min(300, Math.floor(sr)));
    spawnRateInput.value = String(spawnRatePct);
    spawnRateVal.textContent = `${spawnRatePct}%`;
  }

  function updateScoreboard() {
    const items = balls
      .filter(b => b.alive)
      .map(b => {
        const shield = b.shield ? ` <span style="color:#33cfff">ðŸ›¡</span>` : '';
        return `<span class="badge" style="color:${b.color}; border:1px solid ${b.color}">${b.id}: Nivel ${b.level}${shield}</span>`;
      });
    scoreboardEl.innerHTML = items.join('');
  }

  // ---- MORPH ----
  const PILL_NAMES = {
    blue: 'azul',
    red: 'roja',
    greenFast: 'verde claro (2Ã—)',
    greenSlow: 'verde oscuro (0.5Ã—)',
    cyanShield: 'celeste (escudo)',
    yellowMorph: 'amarilla (morph)',
  };
  const MORPH_CHOICES = ['blue','red','greenFast','greenSlow','cyanShield']; // a esto se transforman
  function startMorph(nowMs) {
    const pick = MORPH_CHOICES[Math.floor(Math.random() * MORPH_CHOICES.length)];
    morphType = pick;
    morphUntil = nowMs + MORPH_DURATION_MS;
    // convertir EXISTENTES
    for (const p of pills) { p.type = pick; p.name = PILL_NAMES[pick]; }
    addLog(`Efecto AMARILLO: todas las pÃ­ldoras â†’ ${PILL_NAMES[pick]} por 8s`, 'warn');
  }
  function maybeEndMorph(nowMs) {
    if (morphType && nowMs >= morphUntil) {
      addLog(`Fin efecto AMARILLO (morph)`, 'warn');
      morphType = null;
    }
  }

  function init() {
    paused = false; pauseAccumMs = 0; morphType = null; morphUntil = 0;
    logs.length = 0;
    resize();
    clampInputs();

    // Crear pelotas (radio inicial 25) con colocaciÃ³n que evita overlap
    balls.length = 0;
    const R_INIT = 25;
    for (let i = 0; i < ballCount; i++) {
      const id = `P${i+1}`;
      const color = randomNonBlueRedColor();
      let pos, tries=0;
      do {
        const a = randomAngle();
        const rr = 30 + Math.random()*60; // anillo inicial algo amplio
        pos = { x: Math.cos(a) * rr, y: Math.sin(a) * rr };
        tries++;
      } while (tries < 100 && balls.some(b => Math.hypot(b.pos.x - pos.x, b.pos.y - pos.y) < (b.r + R_INIT + 8)));
      const ball = {
        id, color,
        pos, vel: { x: 0, y: 0 },
        r: R_INIT,                  // â† 25
        level: LEVEL_START,
        alive: true,
        speedEffect: 'none',
        speedEffectUntil: 0,
        noCollideUntil: 0, // set al iniciar
        shield: false,
      };
      balls.push(ball);
      addLog(`${id} listo (nivel ${LEVEL_START})`, 'info');
    }

    // Reset pildoras y timers
    pills.length = 0;
    nextSpawnAt = null;

    // UI
    timeEl.textContent = '0.00';
    state = 'idle';
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = 'Pausar';
    ballCountInput.disabled = false;
    maxPillsInput.disabled = false;
    spawnRateInput.disabled = false;
    toggleEdgeGrowBtn.textContent = `Rebote crece: ${edgeGrowEnabled ? 'ON' : 'OFF'}`;

    updateScoreboard();
    addLog('Configura y pulsa INICIAR', 'info');
    draw();
  }

  function startGame() {
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    ballCountInput.disabled = true;

    const now = performance.now();
    for (const b of balls) {
      const a = randomAngle();
      const v0 = effectiveSpeed(b, now);
      b.vel.x = Math.cos(a) * v0;
      b.vel.y = Math.sin(a) * v0;
      b.noCollideUntil = now + SPAWN_IMMUNITY_MS;
    }

    state = 'running';
    startTime = performance.now();
    addLog('Juego iniciado', 'info');
    scheduleNextSpawn(startTime);
    loop(startTime);
  }

  function loop(prev) {
    rafId = requestAnimationFrame(now => {
      let dt = (now - prev) / 1000;
      if (dt > 0.05) dt = 0.05;
      update(dt, now);
      draw();
      if (state !== 'ended') loop(now);
    });
  }

  function checkWinConditions() {
    const alive = balls.filter(b => b.alive);
    if (alive.length === 0) {
      state = 'ended';
      startBtn.disabled = false; pauseBtn.disabled = true;
      addLog('Todas las pelotas murieron. Sin ganador.', 'warn');
      return true;
    }
    for (const b of alive) {
      if (b.r >= R - 0.5) {
        state = 'ended';
        startBtn.disabled = false; pauseBtn.disabled = true;
        addLog(`${b.id} alcanzÃ³ 100% del tamaÃ±o. Â¡Ganador!`, 'warn');
        return true;
      }
    }
    if (alive.length === 1) {
      state = 'ended';
      startBtn.disabled = false; pauseBtn.disabled = true;
      addLog(`${alive[0].id} es el Ãºltimo con vida. Â¡Ganador!`, 'warn');
      return true;
    }
    return false;
  }

  function update(dt, now) {
    // Crono (no avanza en pausa)
    if (state === 'running' && !paused) {
      elapsed = (now - startTime - pauseAccumMs) / 1000;
      timeEl.textContent = elapsed.toFixed(2);
    }
    if (state !== 'running' || paused) return;

    // Fin de efectos cronometrados
    maybeEndMorph(now);

    // Spawn de pÃ­ldoras (lÃ­mite)
    if (nextSpawnAt !== null && now >= nextSpawnAt) {
      if (pills.length < maxPills) {
        spawnRandomPill(now);
        scheduleNextSpawn(now);
      } else {
        scheduleNextSpawn(now, 800);
      }
    }

    // Actualizar pelotas
    for (const b of balls) {
      if (!b.alive) continue;

      // Velocidad (efectos)
      const targetSpeed = effectiveSpeed(b, now);
      applySpeedToVelocity(b, targetSpeed);

      // Mover
      b.pos.x += b.vel.x * dt;
      b.pos.y += b.vel.y * dt;

      // ColisiÃ³n con borde
      let dist = Math.hypot(b.pos.x, b.pos.y);
      let nx = dist === 0 ? 1 : b.pos.x / dist;
      let ny = dist === 0 ? 0 : b.pos.y / dist;

      const limit = R - b.r;
      const EPS = 0.001;
      const touching = dist >= (limit - EPS);
      const movingOutward = (b.vel.x * nx + b.vel.y * ny) > 0;

      if (touching && movingOutward) {
        b.pos.x = nx * limit;
        b.pos.y = ny * limit;

        if (edgeGrowEnabled) {
          applyGrowthStep(b, 'Rebote');
          if (checkWinConditions()) return;
        }

        // Nueva direcciÃ³n aleatoria hacia adentro
        let vx, vy;
        do {
          const a = randomAngle();
          vx = Math.cos(a) * targetSpeed;
          vy = Math.sin(a) * targetSpeed;
        } while ((vx * nx + vy * ny) >= 0);
        b.vel.x = vx; b.vel.y = vy;

        // EmpujÃ³n hacia adentro
        const newLimit = R - b.r;
        const inset = Math.max(1, targetSpeed * dt);
        const t = Math.max(0, newLimit - inset);
        b.pos.x = nx * t;
        b.pos.y = ny * t;
      }
    }

    // Colisiones pelota-pelota (con inmunidad)
    for (let i = 0; i < balls.length; i++) {
      const A = balls[i]; if (!A.alive) continue;
      for (let j = i+1; j < balls.length; j++) {
        const B = balls[j]; if (!B.alive) continue;

        if (now < A.noCollideUntil || now < B.noCollideUntil) continue;

        const dx = B.pos.x - A.pos.x;
        const dy = B.pos.y - A.pos.y;
        const d = Math.hypot(dx, dy);
        const minDist = A.r + B.r;
        if (d > 0 && d <= minDist) {
          const nx = dx / d, ny = dy / d;
          const overlap = minDist - d + 0.5;
          A.pos.x -= nx * overlap/2; A.pos.y -= ny * overlap/2;
          B.pos.x += nx * overlap/2; B.pos.y += ny * overlap/2;
          const vaDot = A.vel.x*nx + A.vel.y*ny;
          const vbDot = B.vel.x*nx + B.vel.y*ny;
          A.vel.x -= 2*vaDot*nx; A.vel.y -= 2*vaDot*ny;
          B.vel.x -= 2*vbDot*nx; B.vel.y -= 2*vbDot*ny;

          tryShrink(A, `colisiÃ³n con ${B.id}`);
          tryShrink(B, `colisiÃ³n con ${A.id}`);

          if (checkWinConditions()) return;
        }
      }
    }

    // Colisiones con pÃ­ldoras (rombos; colisiÃ³n por radio)
    for (let pi = pills.length - 1; pi >= 0; pi--) {
      const p = pills[pi];
      let consumed = false;

      for (const b of balls) {
        if (!b.alive) continue;
        const d = Math.hypot(b.pos.x - p.x, b.pos.y - p.y);
        if (d <= b.r + PILL_RADIUS) {
          if (p.type === 'blue') {
            applyGrowthStep(b, 'PÃ­ldora azul');
            if (checkWinConditions()) return;
          } else if (p.type === 'red') {
            tryShrink(b, 'PÃ­ldora roja');
            if (checkWinConditions()) return;
          } else if (p.type === 'greenFast') {
            setSpeedEffect(b, 'boost', now);
          } else if (p.type === 'greenSlow') {
            setSpeedEffect(b, 'slow', now);
          } else if (p.type === 'cyanShield') {
            if (b.shield) {
              addLog(`${b.id}: ya tenÃ­a escudo (no acumulable).`, 'warn');
            } else {
              b.shield = true;
              addLog(`${b.id}: obtuvo ESCUDO (1 uso).`, 'info');
              updateScoreboard();
            }
          } else if (p.type === 'yellowMorph') {
            startMorph(now);
          }
          addLog(`${b.id} consumiÃ³ pÃ­ldora ${p.name}.`);
          consumed = true;
          break;
        }
      }
      if (consumed) pills.splice(pi, 1);
    }
  }

  function draw() {
    const cssSize = Math.min(window.innerWidth * 0.96, 900);
    ctx.clearRect(-cssSize/2, -cssSize/2, cssSize, cssSize);

    // Circunferencia grande
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#222';
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, Math.PI * 2);
    ctx.stroke();

    // PÃ­ldoras (rombos)
    for (const p of pills) {
      if (p.type === 'blue') ctx.fillStyle = '#1877F2';
      else if (p.type === 'red') ctx.fillStyle = '#E53935';
      else if (p.type === 'greenFast') ctx.fillStyle = '#7CFC00';
      else if (p.type === 'greenSlow') ctx.fillStyle = '#2E7D32';
      else if (p.type === 'cyanShield') ctx.fillStyle = '#33CFFF';
      else if (p.type === 'yellowMorph') ctx.fillStyle = '#FFD400';

      ctx.beginPath();
      ctx.moveTo(p.x, p.y - PILL_RADIUS);
      ctx.lineTo(p.x + PILL_RADIUS, p.y);
      ctx.lineTo(p.x, p.y + PILL_RADIUS);
      ctx.lineTo(p.x - PILL_RADIUS, p.y);
      ctx.closePath();
      ctx.fill();

      // highlight
      ctx.fillStyle = '#fff8';
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - PILL_RADIUS/1.6);
      ctx.lineTo(p.x + PILL_RADIUS/1.6, p.y);
      ctx.lineTo(p.x, p.y - PILL_RADIUS/2.2);
      ctx.closePath();
      ctx.fill();
    }

    // Pelotas
    for (const b of balls) {
      if (!b.alive) continue;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.pos.x, b.pos.y, b.r, 0, Math.PI * 2);
      ctx.fill();

      // Escudo visual
      if (b.shield) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#33CFFF';
        ctx.beginPath();
        ctx.arc(b.pos.x, b.pos.y, b.r + 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // Mensajes
    ctx.fillStyle = '#333';
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (state === 'idle') ctx.fillText('Configura y haz click en INICIAR', 0, 0);
    if (state === 'ended') ctx.fillText('Juego terminado', 0, 0);
    if (paused && state === 'running') ctx.fillText('PAUSADO (P o Espacio)', 0, 0);
  }

  // Pesos actualizados: azul 150, roja 20, verdeC 15, verdeO 15, celeste 25, amarilla 25
  function spawnRandomPill(now=performance.now()) {
    const weights = [
      {type:'blue',       name:PILL_NAMES.blue,       w:150},
      {type:'red',        name:PILL_NAMES.red,        w:20},
      {type:'greenFast',  name:PILL_NAMES.greenFast,  w:15},
      {type:'greenSlow',  name:PILL_NAMES.greenSlow,  w:15},
      {type:'cyanShield', name:PILL_NAMES.cyanShield, w:25},
      {type:'yellowMorph',name:PILL_NAMES.yellowMorph,w:25},
    ];
    let pick;
    if (morphType) {
      // Mientras dure el morph, TODO spawnea de ese tipo
      pick = { type: morphType, name: PILL_NAMES[morphType] };
    } else {
      const total = weights.reduce((s,o)=>s+o.w,0);
      let r = Math.random()*total;
      for (const o of weights) { r -= o.w; if (r <= 0) { pick = o; break; } }
    }

    const maxR = R - PILL_RADIUS - 4;
    let x=0, y=0;
    for (let tries = 0; tries < 25; tries++) {
      const a = randomAngle();
      const rr = Math.sqrt(Math.random()) * maxR;
      x = Math.cos(a) * rr;
      y = Math.sin(a) * rr;
      let ok = true;
      for (const b of balls) {
        if (!b.alive) continue;
        if (Math.hypot(x - b.pos.x, y - b.pos.y) <= b.r + PILL_RADIUS + 12) { ok = false; break; }
      }
      if (ok) break;
    }
    pills.push({ x, y, type: pick.type, name: pick.name });
    addLog(`Spawn pÃ­ldora ${pick.name} en (${x.toFixed(0)},${y.toFixed(0)})`, 'info');
  }

  // Pausa / reanudar
  function togglePause() {
    if (state !== 'running') return;
    paused = !paused;
    if (paused) {
      pauseStartMs = performance.now();
      pauseBtn.textContent = 'Reanudar';
      addLog('Pausa', 'warn');
    } else {
      const delta = performance.now() - pauseStartMs;
      pauseAccumMs += delta;
      pauseStartMs = 0;
      pauseBtn.textContent = 'Pausar';
      if (nextSpawnAt !== null) nextSpawnAt += delta;
      for (const b of balls) {
        if (b.speedEffect !== 'none') b.speedEffectUntil += delta;
        if (b.noCollideUntil > performance.now()) b.noCollideUntil += delta;
      }
      if (morphType) morphUntil += delta; // extender morph por pausa
      addLog('Reanudar', 'warn');
    }
  }

  // Eventos UI
  startBtn.addEventListener('click', () => { if (state === 'idle') startGame(); });
  resetBtn.addEventListener('click', () => { cancelAnimationFrame(rafId); init(); });
  pauseBtn.addEventListener('click', togglePause);

  ballCountInput.addEventListener('change', () => { if (state==='idle') clampInputs(); });
  maxPillsInput.addEventListener('change', () => { clampInputs(); addLog(`LÃ­mite pÃ­ldoras â†’ ${maxPills}`, 'info'); });
  spawnRateInput.addEventListener('input', () => { clampInputs(); addLog(`Frecuencia spawn â†’ ${spawnRatePct}%`, 'info'); });

  toggleEdgeGrowBtn.addEventListener('click', () => {
    edgeGrowEnabled = !edgeGrowEnabled;
    toggleEdgeGrowBtn.textContent = `Rebote crece: ${edgeGrowEnabled ? 'ON' : 'OFF'}`;
    addLog(`Crecimiento por rebote en borde: ${edgeGrowEnabled ? 'ON' : 'OFF'}`, 'info');
  });

  window.addEventListener('resize', () => { init(); });

  // Logs UI
  toggleLogBtn.addEventListener('click', toggleLogs);
  closeLogBtn.addEventListener('click', toggleLogs);
  clearLogBtn.addEventListener('click', () => { logs.length = 0; renderLogs(); });

  // Hotkeys: P o Espacio para pausa
  window.addEventListener('keydown', (e) => {
    if (e.key === 'p' || e.key === 'P' || e.code === 'Space' || e.key === ' ') {
      e.preventDefault();
      togglePause();
    }
  });

  // Boot
  init();
})();
</script>
</body>
</html>
