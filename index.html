<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bola + Píldoras (crecimiento por fases)</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 0; font-family: system-ui, Segoe UI, Roboto, sans-serif; display: grid; place-items: center; min-height: 100dvh; gap: 12px; }
  .wrap { display: grid; gap: 10px; width: min(720px, 95vw); }
  .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  select { padding: 6px 8px; border-radius: 10px; border: 1px solid #8884; }
  button { padding: 8px 14px; border: 0; border-radius: 12px; cursor: pointer; box-shadow: 0 2px 10px #0002; }
  button:disabled, select:disabled { opacity: 0.6; cursor: not-allowed; }
  .hud { font-weight: 600; }
  canvas { width: 100%; aspect-ratio: 1 / 1; background: conic-gradient(from 180deg at 50% 50%, #fff0, #fff0); border-radius: 16px; box-shadow: inset 0 0 0 1px #0002; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="controls">
      <label>Velocidad:
        <select id="speedSel">
          <option value="0.5">x0.5</option>
          <option value="1" selected>x1</option>
          <option value="1.5">x1.5</option>
          <option value="2">x2</option>
          <option value="3">x3</option>
        </select>
      </label>
      <button id="start">INICIAR</button>
      <button id="reset">Reiniciar</button>
      <div class="hud">
        Tiempo: <span id="time">0.00</span>s ·
        Crecimientos: <span id="sizeSteps">1</span> ·
        Fase: <span id="phasePct">25%</span>
      </div>
    </div>
    <canvas id="game"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const speedSel = document.getElementById('speedSel');
  const startBtn = document.getElementById('start');
  const resetBtn = document.getElementById('reset');
  const timeEl = document.getElementById('time');
  const sizeStepsEl = document.getElementById('sizeSteps');
  const phasePctEl = document.getElementById('phasePct');

  let state = 'idle'; // 'idle' | 'running' | 'ended'
  let R, r, pos, vel, baseSpeed, speedMul, speed, ballColor;
  let sizeSteps = 1, startTime = 0, elapsed = 0, rafId = null;

  // Crecimiento por fases: 25% (x5) -> 20% (x5) -> 15% (x5) -> 10% (x5) -> 5% (∞)
  let growthPct, growthUsesLeft; // pct de la fase actual y usos restantes en la fase

  // Píldoras
  const pills = [];
  const PILL_RADIUS = 8;
  let nextSpawnAt = null; // timestamp (performance.now) para siguiente spawn

  function randomRange(a, b) { return a + Math.random() * (b - a); }

  function scheduleNextSpawn(now = performance.now()) {
    // Próximo spawn entre 1.5s y 4s desde ahora
    nextSpawnAt = now + randomRange(1500, 4000);
  }

  function randomNonBlueRedColor() {
    // Evitar rojos (~[-15,15]) y azules (~[200,260]) en hue
    while (true) {
      const h = Math.floor(Math.random() * 360);
      const redZone = (h <= 15 || h >= 345);
      const blueZone = (h >= 200 && h <= 260);
      if (!redZone && !blueZone) {
        const s = 70 + Math.random() * 20;
        const l = 55 + Math.random() * 15;
        return `hsl(${h} ${s}% ${l}%)`;
      }
    }
  }

  function resetGrowthSchedule() {
    growthPct = 25;
    growthUsesLeft = 5;
    updatePhaseHud();
  }
  function updatePhaseHud() {
    phasePctEl.textContent = `${growthPct}%`;
  }
  function currentShrinkPct() {
    // pct de la fase anterior (ej.: si actual=20 → shrink=25; si actual=5 → shrink=10)
    // Nota: en 25% la "anterior" también la tratamos como 25%.
    return Math.min(25, growthPct + 5);
  }

  function applyGrowthStep() {
    // Crece según la fase actual
    r = Math.min(R, r * (1 + growthPct / 100));
    // Avanza la fase (consumimos un uso) porque esto cuenta como un "crecimiento"
    if (growthUsesLeft > 0) growthUsesLeft--;
    if (growthUsesLeft === 0 && growthPct > 5) {
      growthPct = Math.max(5, growthPct - 5);
      growthUsesLeft = (growthPct === 5) ? Infinity : 5;
      updatePhaseHud();
    }
    sizeSteps++; // contador de crecimientos (+1)
    sizeStepsEl.textContent = String(sizeSteps);
  }

  function applyShrinkStep() {
    // Decrece usando la fase ANTERIOR, para volver a un tamaño "previo"
    const prevPct = currentShrinkPct();
    r = Math.max(2, r / (1 + prevPct / 100)); // inverso multiplicativo (ej. /1.25)
    sizeSteps--; // contador de crecimientos (-1)
    sizeStepsEl.textContent = String(sizeSteps);
  }

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssSize = Math.min(window.innerWidth * 0.95, 720);
    canvas.width = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    ctx.translate(cssSize/2, cssSize/2);
    R = (cssSize/2) - 10;
    baseSpeed = R * 0.45; // px/seg a x1
    updateSpeedFromUI();
  }

  function updateSpeedFromUI() {
    speedMul = Number(speedSel.value) || 1;
    speed = baseSpeed * speedMul;
  }

  function init() {
    resize();
    r = 10;
    pos = { x: 0, y: 0 };
    vel = { x: 0, y: 0 };
    sizeSteps = 1;
    sizeStepsEl.textContent = String(sizeSteps);
    elapsed = 0;
    ballColor = randomNonBlueRedColor(); // color fijo aleatorio (no azul/rojo)
    resetGrowthSchedule();
    timeEl.textContent = '0.00';
    state = 'idle';
    speedSel.disabled = false;
    startBtn.disabled = false;
    pills.length = 0;
    nextSpawnAt = null;
    draw();
  }

  function startGame() {
    speedSel.disabled = true;
    startBtn.disabled = true;

    // Dirección aleatoria inicial
    const a = Math.random() * Math.PI * 2;
    vel.x = Math.cos(a) * speed;
    vel.y = Math.sin(a) * speed;

    state = 'running';
    startTime = performance.now();
    scheduleNextSpawn(startTime);
    loop(startTime);
  }

  function loop(prev) {
    rafId = requestAnimationFrame(now => {
      let dt = (now - prev) / 1000;
      if (dt > 0.05) dt = 0.05; // evita saltos grandes
      update(dt, now);
      draw();
      if (state === 'running') loop(now);
    });
  }

  function update(dt, now) {
    if (state !== 'running') return;
    elapsed = (performance.now() - startTime) / 1000;
    timeEl.textContent = elapsed.toFixed(2);

    // Spawning de píldoras
    if (nextSpawnAt !== null && now >= nextSpawnAt) {
      spawnRandomPill();
      scheduleNextSpawn(now);
    }

    // Mover
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;

    // Colisión con borde (con tolerancia + anti rebote fantasma)
    let dist = Math.hypot(pos.x, pos.y);
    let nx = dist === 0 ? 1 : pos.x / dist; // normal hacia afuera
    let ny = dist === 0 ? 0 : pos.y / dist;

    const limit = R - r;
    const EPS = 0.001;
    const touching = dist >= (limit - EPS);
    const movingOutward = (vel.x * nx + vel.y * ny) > 0; // solo colisiona si iba saliendo

    if (touching && movingOutward) {
      // Colocar exactamente en el borde actual
      pos.x = nx * limit;
      pos.y = ny * limit;

      // CRECER por fase (esto cuenta como "crecimiento")
      applyGrowthStep();

      // ¿Fin del juego?
      if (r >= R - 0.5) {
        state = 'ended';
        speedSel.disabled = false;
        startBtn.disabled = false;
        cancelAnimationFrame(rafId);
        return;
      }

      // Nueva dirección aleatoria HACIA ADENTRO (vel · normal < 0)
      let vx, vy;
      do {
        const a = Math.random() * Math.PI * 2;
        vx = Math.cos(a) * speed;
        vy = Math.sin(a) * speed;
      } while ((vx * nx + vy * ny) >= 0);

      vel.x = vx;
      vel.y = vy;

      // Empujón hacia adentro tras crecer (evita doble colisión inmediata)
      const newLimit = R - r;
      const inset = Math.max(1, speed * dt);
      const target = Math.max(0, newLimit - inset);
      pos.x = nx * target;
      pos.y = ny * target;

      // Recalcular normal (opcional)
      dist = Math.hypot(pos.x, pos.y);
      nx = dist === 0 ? 1 : pos.x / dist;
      ny = dist === 0 ? 0 : pos.y / dist;
    }

    // Colisión con píldoras (no rebotan)
    for (let i = pills.length - 1; i >= 0; i--) {
      const p = pills[i];
      const d = Math.hypot(pos.x - p.x, pos.y - p.y);
      if (d <= r + PILL_RADIUS) {
        if (p.type === 'blue') {
          applyGrowthStep(); // crecer como si fuera rebote
          if (r >= R - 0.5) {
            state = 'ended';
            speedSel.disabled = false;
            startBtn.disabled = false;
            cancelAnimationFrame(rafId);
            return;
          }
        } else {
          applyShrinkStep(); // decrecer con fase anterior (inverso exacto)
        }
        pills.splice(i, 1); // consumida
      }
    }
  }

  function draw() {
    const cssSize = Math.min(window.innerWidth * 0.95, 720);
    ctx.clearRect(-cssSize/2, -cssSize/2, cssSize, cssSize);

    // Circunferencia grande
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#222';
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, Math.PI * 2);
    ctx.stroke();

    // Píldoras (persisten hasta consumirse)
    for (const p of pills) {
      ctx.fillStyle = (p.type === 'blue') ? '#1877F2' : '#E53935'; // azul/rojo visibles
      ctx.beginPath();
      ctx.arc(p.x, p.y, PILL_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      // un pequeño brillo
      ctx.fillStyle = '#fff8';
      ctx.beginPath();
      ctx.arc(p.x - PILL_RADIUS/3, p.y - PILL_RADIUS/3, PILL_RADIUS/3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Pelota (color fijo aleatorio, no cambia)
    ctx.fillStyle = ballColor;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Mensaje
    ctx.fillStyle = '#333';
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (state === 'idle') ctx.fillText('Haz click en INICIAR', 0, 0);
    if (state === 'ended') ctx.fillText('¡Fin! Alcanzaste el 100%', 0, 0);
  }

  function spawnRandomPill() {
    // Tipo aleatorio 50/50
    const type = Math.random() < 0.5 ? 'blue' : 'red';
    // Posición aleatoria dentro del círculo (evitar bordes)
    // Elegimos un radio uniforme en área: r = sqrt(u) * max
    const maxR = R - PILL_RADIUS - 4;
    let x, y;
    for (let tries = 0; tries < 20; tries++) {
      const a = Math.random() * Math.PI * 2;
      const rr = Math.sqrt(Math.random()) * maxR;
      x = Math.cos(a) * rr;
      y = Math.sin(a) * rr;
      // evitar spawnear encima de la pelota (opcional)
      if (Math.hypot(x - pos.x, y - pos.y) > (r + PILL_RADIUS + 12)) break;
    }
    pills.push({ x, y, type });
  }

  // Eventos
  startBtn.addEventListener('click', () => { if (state === 'idle') startGame(); });
  resetBtn.addEventListener('click', () => { cancelAnimationFrame(rafId); init(); });
  speedSel.addEventListener('change', () => { if (state === 'idle') { updateSpeedFromUI(); } });
  window.addEventListener('resize', () => { init(); });

  // Boot
  init();
})();
</script>
</body>
</html>
